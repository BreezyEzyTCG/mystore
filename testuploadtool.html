<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Secure Payment Proof Upload (Demo)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; }
    .card { max-width: 520px; border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; }
    .row { margin: 10px 0; }
    .hint { color: #6b7280; font-size: 0.9rem; }
    .btn { padding: 10px 14px; border: 0; border-radius: 8px; cursor: pointer; }
    .btn-primary { background: black; color: white; }
    progress { width: 100%; height: 10px; }
    .ok { color: #065f46; }
    .err { color: #991b1b; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="card">
    <h2>Upload payment proof</h2>
    <p class="hint">Your file goes privately to the owner. Others can’t view your upload.</p>

    <!-- NOTE: We keep action for reference, but the JS will prevent the default submit -->
    <form id="uform" action="https://script.google.com/macros/s/AKfycbxriS7NptwgUanj7DIRS0SO6_CvbWAr6RgFKt3LetnGcT1RoRIGnkZGvJsDrcR_TwKR/exec" method="POST">
      <!-- Visible inputs -->
      <div class="row">
        <label>Screenshot (PNG/JPG)
          <input id="file" type="file" accept="image/*" required />
        </label>
      </div>

      <div class="row">
        <label>Note (optional)
          <input name="note" id="note" type="text" placeholder="Order #1234" />
        </label>
      </div>

      <!-- Hidden fields (we still fill these; Ajax will read from them) -->
      <input type="hidden" name="file_b64" id="file_b64" />
      <input type="hidden" name="filename" id="filename" />
      <input type="hidden" name="mimetype" id="mimetype" />

      <div class="row">
        <progress id="prog" max="100" value="0" class="hidden"></progress>
        <div id="status" class="hint"></div>
      </div>

      <div class="row">
        <button class="btn btn-primary" id="submitBtn" type="submit" disabled>Upload</button>
      </div>
    </form>
  </div>

  <script>
    const fileInput = document.getElementById('file');
    const noteInput = document.getElementById('note');
    const b64Field  = document.getElementById('file_b64');
    const nameField = document.getElementById('filename');
    const mimeField = document.getElementById('mimetype');
    const prog      = document.getElementById('prog');
    const statusEl  = document.getElementById('status');
    const submitBtn = document.getElementById('submitBtn');
    const form      = document.getElementById('uform');

    let fileReady = false;

    fileInput.addEventListener('change', () => {
      const f = fileInput.files[0];
      if (!f) return;

      // Basic guardrails (adjust as you like)
      const okTypes = ['image/png', 'image/jpeg', 'image/webp', 'image/heic', 'image/heif'];
      if (!okTypes.includes(f.type)) {
        statusEl.textContent = 'Please choose a PNG or JPG (or common image).';
        submitBtn.disabled = true;
        return;
      }
      if (f.size > 15 * 1024 * 1024) { // 15 MB
        statusEl.textContent = 'File too large (limit 15 MB for this demo).';
        submitBtn.disabled = true;
        return;
      }

      statusEl.textContent = 'Preparing your file…';
      prog.classList.remove('hidden');
      prog.value = 5;

      const reader = new FileReader();
      reader.onprogress = (e) => {
        if (e.lengthComputable) {
          prog.value = Math.min(95, Math.round((e.loaded / e.total) * 95));
        }
      };
      reader.onload = () => {
        // reader.result is a data URL: "data:image/png;base64,AAAA..."
        const comma = reader.result.indexOf(',');
        const b64 = reader.result.slice(comma + 1);
        b64Field.value = b64;
        nameField.value = f.name;
        mimeField.value = f.type || 'application/octet-stream';
        fileReady = true;
        submitBtn.disabled = false;
        prog.value = 100;
        statusEl.textContent = 'Ready to upload.';
      };
      reader.onerror = () => {
        statusEl.textContent = 'Could not read the file.';
        submitBtn.disabled = true;
      };
      reader.readAsDataURL(f);
    });

    // ---- NEW: Ajax/Fetch submit (no redirect) ----
    form.addEventListener('submit', async (e) => {
      e.preventDefault(); // <— stop the browser from navigating
      if (!fileReady || !b64Field.value) {
        statusEl.textContent = 'Choose a file first.';
        return;
      }

      submitBtn.disabled = true;
      statusEl.textContent = 'Uploading…';

      // Build the same payload your Apps Script already expects
      const payload = {
        file_b64: b64Field.value,
        filename: nameField.value,
        mimetype: mimeField.value,
        note: noteInput?.value || ''
      };

      // We try CORS first (best case: Apps Script returns JSON + CORS headers).
      try {
        const res = await fetch(form.action, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },   // <— send JSON
          body: JSON.stringify(payload),
          // mode: 'cors'  // default; we keep it implicit
        });

        // If Apps Script sends JSON, show real result:
        const ct = res.headers.get('content-type') || '';
        if (ct.includes('application/json')) {
          const data = await res.json();
          if (data && (data.ok || data.success)) {
            statusEl.textContent = 'Upload complete ✓';
            statusEl.classList.add('ok');
            statusEl.classList.remove('err');
            return;
          } else {
            throw new Error(data?.error || 'Upload failed at server');
          }
        }

        // If it wasn't JSON, we still treat 200s as success
        if (res.ok) {
          statusEl.textContent = 'Upload complete ✓';
          statusEl.classList.add('ok');
          statusEl.classList.remove('err');
          return;
        }

        // Non-OK HTTP
        throw new Error('Server returned ' + res.status);
      } catch (errCors) {
        // Fallback for when Apps Script doesn’t have CORS enabled.
        // We send again in "no-cors" mode (we can’t read the response, but the server will still receive it).
        try {
          await fetch(form.action, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            mode: 'no-cors' // <— fire-and-forget; cannot read response
          });
          // We optimistically show success (because we can’t read the reply in no-cors).
          statusEl.textContent = 'Upload sent ✓ (waiting on server)';
          statusEl.classList.add('ok');
          statusEl.classList.remove('err');
        } catch (errNoCors) {
          console.error(errNoCors);
          statusEl.textContent = 'Upload failed. Please try again.';
          statusEl.classList.add('err');
          statusEl.classList.remove('ok');
          submitBtn.disabled = false;
        }
      }
    });
    // ---- end NEW ----
  </script>
</body>
</html>
